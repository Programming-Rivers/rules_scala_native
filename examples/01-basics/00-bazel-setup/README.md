# Bazel Setup for Scala Native

This example introduces the basics of using Bazel with Scala Native, focusing on project configuration and dependency management.

## Prerequisites
*   **Bazel**: Bazel 9.0 or higher is required.

## Bazel Basics

A Bazel project (using **Bzlmod**) interact with three files, one of which is automatically generated:

*   **`MODULE.bazel`**: This file defines the project and lists its external dependencies. It's like `build.sbt` in Scala SBT projects.
*   **`MODULE.bazel.lock`**: This file is automatically generated and contains the resolved versions of the dependencies.
    It ensures every developer and CI runner uses the exact same version of every dependency.
    It's like `package-lock.json` in npm or `Cargo.lock` in Rust.
*   **`BUILD.bazel`**: This file contains "recipes" for building your code. Each recipe is called a **Target**.

> **Note**: Older Bazel tutorials might mention a `WORKSPACE` file. `WORKSPACE` was deprecated in Bazel 7 in favor of Bazel Modules (bzlmod) and `MODULE.bazel`.
As of Bazel 9, `WORKSPACE` is completely removed.

### Project Structure

A minimal setup looks like this:

```text
00-bazel-setup/
├── MODULE.bazel               # External dependencies
├── MODULE.bazel.lock          # Automatically generated
├── BUILD.bazel                # Build targets (recipes)
└── .bazelrc                   # (Optional) Bazel configuration options
```

## Configuration Files

### `MODULE.bazel`

The `MODULE.bazel` file in this example does three main things:
1.  **Declares the module**: Sets the name and version of this project.
2.  **Adds dependencies**: Brings in `rules_scala` and `rules_scala_native`.
3.  **Configures Toolchains**: Sets up the Scala version and registers the necessary compilers and toolchains.

### `BUILD.bazel`

The `BUILD.bazel` file defines how to build the source code.
For Scala Native, it needs to use the following rules:
* `scala_native_library`
* `scala_native_binary`

## Managing Dependencies with `bazel mod`

The `bazel mod` command is the primary tool for inspecting and managing the module graph.
Here are some examples:

### Inspect the dependency graph
Shows the resolved module graph: the module plus all its dependencies (direct and transitive).

```bash
bazel mod graph
```
The output graph will likely be very larg and may contain surprising dependencies.
For exapmle, the depenencies for the simplest Scala Native project may include a section such as
```
$ bazel mod graph
<root> (example_00_bazel_setup@_)
├───protobuf@33.4 
├

...

    ├───rules_python@1.7.0                <---------------- Python
    │   ├───protobuf@33.4 (cycle) 
    │   ├───bazel_features@1.34.0 (*) 
    │   ├───bazel_skylib@1.8.2 (*) 
    │   ├───platforms@1.0.0 (*) 
    │   ├───rules_cc@0.2.16 (*)           <---------------- C and C++
    │   └───stardoc@0.7.2 
    │       ├───protobuf@33.4 (cycle) 
    │       ├───bazel_skylib@1.8.2 (*) 
    │       ├───rules_java@9.3.0 (*)      <---------------- Java
    │       ├───rules_jvm_external@6.7 (*) 
    │       └───rules_license@1.0.0 (*) 

...

        ├───tar.bzl@0.6.0                 <---------------- tar
        │   ├───bazel_features@1.34.0 (*) 
        │   ├───bazel_skylib@1.8.2 (*) 
        │   ├───platforms@1.0.0 (*) 
        │   ├───aspect_bazel_lib@2.19.3 
        │   │   ├───tar.bzl@0.6.0 (cycle) 
```
### Explain why a module is present
The `bazel mod explain` command shows why a given module is part of the dependency graph and which dependency path pulled it in.

For example, to see why `tar.bzl` is part of the dependency graph:

```bash
$ bazel mod explain tar.bzl
<root> (example_00_bazel_setup@_)
└───rules_scala_native@_ 
    └───toolchains_llvm_bootstrapped@0.5.9 
        └───tar.bzl@0.6.0 # 
```
The output shows that `tar.bzl` is part of the dependency graph because it is a dependency of `toolchains_llvm_bootstrapped`, which is a dependency of `rules_scala_native`, which is a dependency of your module.

## Code Highlights

### `MODULE.bazel`
```python
# MODULE.bazel

# Name of this module
module(name = "example_00_bazel_setup")

# Add dependencies
bazel_dep(name = "rules_scala", version = "7.2.2")
bazel_dep(name = "rules_scala_native", version = "0.1.0")

# Configure Scala
scala_config = use_extension("@rules_scala//scala/extensions:config.bzl", "scala_config")
scala_config.settings(scala_version = "3.8.1")  # Configure Scala version
scala_deps = use_extension("@rules_scala//scala/extensions:deps.bzl", "scala_deps")
scala_deps.scala()
use_repo(scala_deps, "rules_scala_toolchains")
register_toolchains("@rules_scala_toolchains//...:all")

# Configure Scala Native
scala_native_deps = use_extension("@rules_scala_native//scala_native/extensions:deps.bzl", "scala_native_deps")
use_repo(
    scala_native_deps,
    "org_scala_native_auxlib",
    "org_scala_native_clib",
    "org_scala_native_javalib",
    "org_scala_native_nativelib",
    "org_scala_native_nir",
    "org_scala_native_nscplugin",
    "org_scala_native_posixlib",
    "org_scala_native_scalalib",
    "org_scala_native_tools",
    "org_scala_native_util",
    "org_scala_native_windowslib",
)
```

### `BUILD.bazel`
```python
# BUILD.bazel

# Instruct bazel that the scala_native_binary is required to build this package.
load(
    "@rules_scala_native//scala_native:scala_native_binary.bzl",
    "scala_native_binary",
)

# Instruct bazel that the scala_native_library is required to build this package.
load(
    "@rules_scala_native//scala_native:scala_native_library.bzl",
    "scala_native_library",
)
```

## Next Steps

Now that you understand how Bazel is set up, let's create a real "Hello World" application.

→ [01-hello-world](../01-hello-world/): Create and run your first Scala Native binary.
